/// This file is auto-generated by Scribble and shouldn't be edited directly.
/// Use --disarm prior to make any changes.
pragma solidity >=0.4.22<0.6.0;

contract owned {
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    constructor() public {
        owner = msg.sender;
    }

    function transferOwnership(address newOwner) public onlyOwner() {
        owner = newOwner;
    }
}

contract tokenRecipient {
    event receivedEther(address sender, uint amount);

    event receivedTokens(address _from, uint256 _value, address _token, bytes _extraData);

    function receiveApproval(address _from, uint256 _value, address _token, bytes memory _extraData) public {
        Token t = Token(_token);
        require(t.transferFrom(_from, address(this), _value));
        emit receivedTokens(_from, _value, _token, _extraData);
    }

    function () external payable {
        emit receivedEther(msg.sender, msg.value);
    }
}

interface Token {
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

contract Congress is owned, tokenRecipient {
    event ProposalAdded(uint proposalID, address recipient, uint amount, string description);

    event Voted(uint proposalID, bool position, address voter, string justification);

    event ProposalTallied(uint proposalID, int result, uint quorum, bool active);

    event MembershipChanged(address member, bool isMember);

    event ChangeOfRules(uint newMinimumQuorum, uint newDebatingPeriodInMinutes, int newMajorityMargin);

    struct Proposal {
        address recipient;
        uint amount;
        string description;
        uint minExecutionDate;
        bool executed;
        bool proposalPassed;
        uint numberOfVotes;
        int currentResult;
        bytes32 proposalHash;
        Vote[] votes;
        mapping(address => bool) voted;
    }

    struct Member {
        address member;
        string name;
        uint memberSince;
    }

    struct Vote {
        bool inSupport;
        address voter;
        string justification;
    }

    uint public minimumQuorum;
    uint public debatingPeriodInMinutes;
    int public majorityMargin;
    Proposal[] public proposals;
    uint public numProposals;
    mapping(address => uint) public memberId;
    Member[] public members;

    modifier onlyMembers() {
        require(memberId[msg.sender] != 0);
        _;
    }

    /// Constructor
    constructor(uint minimumQuorumForProposals, uint minutesForDebate, int marginOfVotesForMajority) public payable {
        changeVotingRules(minimumQuorumForProposals, minutesForDebate, marginOfVotesForMajority);
        addMember(address(0), "");
        addMember(owner, "founder");
    }

    /// Add member
    /// 
    /// Make `targetMember` a member named `memberName`
    /// 
    /// @param targetMember ethereum address to be added
    /// @param memberName public name for that member
    function addMember(address targetMember, string memory memberName) public onlyOwner() {
        uint id = memberId[targetMember];
        if (id == 0) {
            memberId[targetMember] = members.length;
            id = members.length++;
        }
        members[id] = Member({member: targetMember, memberSince: now, name: memberName});
        emit MembershipChanged(targetMember, true);
    }

    /// Remove member
    /// 
    /// @notice Remove membership from `targetMember`
    /// 
    /// @param targetMember ethereum address to be removed
    function removeMember(address targetMember) public onlyOwner() {
        require(memberId[targetMember] != 0);
        for (uint i = memberId[targetMember]; i < (members.length - 1); i++) {
            members[i] = members[i + 1];
            memberId[members[i].member] = i;
        }
        memberId[targetMember] = 0;
        delete members[members.length - 1];
        members.length--;
    }

    /// Change voting rules
    /// 
    /// Make so that proposals need to be discussed for at least `minutesForDebate/60` hours,
    /// have at least `minimumQuorumForProposals` votes, and have 50% + `marginOfVotesForMajority` votes to be executed
    /// 
    /// @param minimumQuorumForProposals how many members must vote on a proposal for it to be executed
    /// @param minutesForDebate the minimum amount of delay between when a proposal is made and when it can be executed
    /// @param marginOfVotesForMajority the proposal needs to have 50% plus this number
    function changeVotingRules(uint minimumQuorumForProposals, uint minutesForDebate, int marginOfVotesForMajority) public onlyOwner() {
        minimumQuorum = minimumQuorumForProposals;
        debatingPeriodInMinutes = minutesForDebate;
        majorityMargin = marginOfVotesForMajority;
        emit ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, majorityMargin);
    }

    /// Add Proposal
    /// 
    /// Propose to send `weiAmount / 1e18` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.
    /// 
    /// @param beneficiary who to send the ether to
    /// @param weiAmount amount of ether to send, in wei
    /// @param jobDescription Description of job
    /// @param transactionBytecode bytecode of transaction
    function newProposal(address beneficiary, uint weiAmount, string memory jobDescription, bytes memory transactionBytecode) public onlyMembers() returns (uint proposalID) {
        proposalID = proposals.length++;
        Proposal storage p = proposals[proposalID];
        p.recipient = beneficiary;
        p.amount = weiAmount;
        p.description = jobDescription;
        p.proposalHash = keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));
        p.minExecutionDate = now + (debatingPeriodInMinutes * 1 minutes);
        p.executed = false;
        p.proposalPassed = false;
        p.numberOfVotes = 0;
        emit ProposalAdded(proposalID, beneficiary, weiAmount, jobDescription);
        numProposals = proposalID + 1;
        return proposalID;
    }

    /// Add proposal in Ether
    /// 
    /// Propose to send `etherAmount` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.
    /// This is a convenience function to use if the amount to be given is in round number of ether units.
    /// 
    /// @param beneficiary who to send the ether to
    /// @param etherAmount amount of ether to send
    /// @param jobDescription Description of job
    /// @param transactionBytecode bytecode of transaction
    function newProposalInEther(address beneficiary, uint etherAmount, string memory jobDescription, bytes memory transactionBytecode) public onlyMembers() returns (uint proposalID) {
        return newProposal(beneficiary, etherAmount * 1 ether, jobDescription, transactionBytecode);
    }

    /// Check if a proposal code matches
    /// 
    /// @param proposalNumber ID number of the proposal to query
    /// @param beneficiary who to send the ether to
    /// @param weiAmount amount of ether to send
    /// @param transactionBytecode bytecode of transaction
    function checkProposalCode(uint proposalNumber, address beneficiary, uint weiAmount, bytes memory transactionBytecode) public view returns (bool codeChecksOut) {
        Proposal storage p = proposals[proposalNumber];
        return p.proposalHash == keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));
    }

    /// Log a vote for a proposal
    /// 
    /// Vote `supportsProposal? in support of : against` proposal #`proposalNumber`
    /// 
    /// @param proposalNumber number of proposal
    /// @param supportsProposal either in favor or against it
    /// @param justificationText optional justification text
    function vote(uint proposalNumber, bool supportsProposal, string memory justificationText) public onlyMembers() returns (uint voteID) {
        {}
        Proposal storage p = proposals[proposalNumber];
        {
            if (!(memberId[msg.sender] != 0)) {
                __ScribbleUtilsLib__733.assertionFailed("008086:0083:000 0: Only members can vote");
                assert(false);
            }
            if (!(p.voted[msg.sender] == true)) {
                __ScribbleUtilsLib__733.assertionFailed("008282:0085:000 1: Single vote per address");
                assert(false);
            }
        }
        require(!p.voted[msg.sender]);
        p.voted[msg.sender] = true;
        p.numberOfVotes++;
        if (supportsProposal) {
            p.currentResult++;
        } else {
            p.currentResult--;
        }
        emit Voted(proposalNumber, supportsProposal, msg.sender, justificationText);
        return p.numberOfVotes;
    }

    /// Finish vote
    /// 
    /// Count the votes proposal #`proposalNumber` and execute it if approved
    /// 
    /// @param proposalNumber proposal number
    /// @param transactionBytecode optional: if the transaction contained a bytecode, you need to send it
    function executeProposal(uint proposalNumber, bytes memory transactionBytecode) public {
        {}
        Proposal storage p = proposals[proposalNumber];
        {
            if (!(p.numberOfVotes >= minimumQuorum)) {
                __ScribbleUtilsLib__733.assertionFailed("009280:0092:000 2: Quorum is met before execution");
                assert(false);
            }
        }
        require((((now > p.minExecutionDate) && (!p.executed)) && (p.proposalHash == keccak256(abi.encodePacked(p.recipient, p.amount, transactionBytecode)))) && (p.numberOfVotes >= minimumQuorum));
        if (p.currentResult > majorityMargin) {
            p.executed = true;
            (bool success, ) = p.recipient.call.value(p.amount)(transactionBytecode);
            require(success);
            p.proposalPassed = true;
        } else {
            p.proposalPassed = false;
        }
        emit ProposalTallied(proposalNumber, p.currentResult, p.numberOfVotes, p.proposalPassed);
    }
}

library __ScribbleUtilsLib__733 {
    event AssertionFailed(string message);

    event AssertionFailedData(int eventId, bytes encodingData);

    function assertionFailed(string memory arg_0) internal {
        emit AssertionFailed(arg_0);
    }

    function assertionFailedData(int arg_0, bytes memory arg_1) internal {
        emit AssertionFailedData(arg_0, arg_1);
    }

    function isInContract() internal returns (bool res) {
        assembly {
            res := sload(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c)
        }
    }

    function setInContract(bool v) internal {
        assembly {
            sstore(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c, v)
        }
    }
}