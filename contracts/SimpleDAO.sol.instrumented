/// This file is auto-generated by Scribble and shouldn't be edited directly.
/// Use --disarm prior to make any changes.
/// SPDX-License-Identifier: MIT
pragma solidity ^0.8.29;

/// @title SimpleDAO
///  @notice A simple DAO voting mechanism with token-weighted voting
///  @dev Uses Scribble annotations for formal verification
contract SimpleDAO {
    event ProposalCreated(uint256 indexed proposalId, string description);

    event VoteCast(uint256 indexed proposalId, address indexed voter, bool support);

    event ProposalExecuted(uint256 indexed proposalId, bool passed);

    struct Proposal {
        string description;
        uint256 yesVotes;
        uint256 noVotes;
        uint256 startTime;
        uint256 endTime;
        bool executed;
        mapping(address => bool) hasVoted;
    }

    struct vars1 {
        uint256 old_0;
    }

    struct vars2 {
        uint256 old_1;
        uint256 old_2;
    }

    address public admin;
    mapping(uint256 => Proposal) public proposals;
    mapping(address => uint256) public tokenBalances;
    uint256 public proposalCount;

    /// #if_succeeds msg.sender == admin;
    modifier onlyAdmin() {
        require(msg.sender == admin, "Only admin can call this function");
        _;
    }

    /// #if_succeeds tokenBalances[msg.sender] > 0;
    modifier onlyTokenHolder() {
        require(tokenBalances[msg.sender] > 0, "Must be a token holder");
        _;
    }

    /// #if_succeeds admin == msg.sender;
    constructor() {
        admin = msg.sender;
        unchecked {
            if (!(admin == msg.sender)) {
                emit __ScribbleUtilsLib__346.AssertionFailed("001605:0067:000 0: ");
                assert(false);
            }
        }
    }

    function createProposal(string memory _description, uint256 _votingPeriod) external returns (uint256 RET_0) {
        vars1 memory _v;
        unchecked {
            _v.old_0 = proposalCount;
        }
        RET_0 = _original_SimpleDAO_createProposal(_description, _votingPeriod);
        unchecked {
            if (!(msg.sender == admin)) {
                emit __ScribbleUtilsLib__346.AssertionFailed("002102:0067:000 1: ");
                assert(false);
            }
            if (!((_votingPeriod > 0) && (_votingPeriod <= 604800))) {
                emit __ScribbleUtilsLib__346.AssertionFailed("002303:0067:000 2: ");
                assert(false);
            }
            if (!(proposals[proposalCount].startTime == block.timestamp)) {
                emit __ScribbleUtilsLib__346.AssertionFailed("002509:0067:000 3: ");
                assert(false);
            }
            if (!(proposals[proposalCount].endTime == (block.timestamp + _votingPeriod))) {
                emit __ScribbleUtilsLib__346.AssertionFailed("002731:0067:000 4: ");
                assert(false);
            }
            if (!(proposalCount == (_v.old_0 + 1))) {
                emit __ScribbleUtilsLib__346.AssertionFailed("002915:0067:000 5: ");
                assert(false);
            }
        }
    }

    function _original_SimpleDAO_createProposal(string memory _description, uint256 _votingPeriod) internal onlyAdmin() returns (uint256) {
        require((_votingPeriod > 0) && (_votingPeriod <= 7 days), "Invalid voting period");
        uint256 proposalId = proposalCount++;
        Proposal storage proposal = proposals[proposalId];
        proposal.description = _description;
        proposal.startTime = block.timestamp;
        proposal.endTime = block.timestamp + _votingPeriod;
        emit ProposalCreated(proposalId, _description);
        return proposalId;
    }

    function vote(uint256 _proposalId, bool _support) external {
        vars2 memory _v;
        unchecked {
            _v.old_1 = proposals[_proposalId].yesVotes;
            _v.old_2 = proposals[_proposalId].noVotes;
        }
        _original_SimpleDAO_vote(_proposalId, _support);
        unchecked {
            if (!(tokenBalances[msg.sender] > 0)) {
                emit __ScribbleUtilsLib__346.AssertionFailed("004000:0067:000 6: ");
                assert(false);
            }
            if (!(block.timestamp >= proposals[_proposalId].startTime)) {
                emit __ScribbleUtilsLib__346.AssertionFailed("004204:0067:000 7: ");
                assert(false);
            }
            if (!(block.timestamp <= proposals[_proposalId].endTime)) {
                emit __ScribbleUtilsLib__346.AssertionFailed("004406:0067:000 8: ");
                assert(false);
            }
            if (!(!proposals[_proposalId].hasVoted[msg.sender])) {
                emit __ScribbleUtilsLib__346.AssertionFailed("004603:0067:000 9: ");
                assert(false);
            }
            if (!(proposals[_proposalId].hasVoted[msg.sender])) {
                emit __ScribbleUtilsLib__346.AssertionFailed("004799:0068:000 10: ");
                assert(false);
            }
            if (!(_support ? (proposals[_proposalId].yesVotes == (_v.old_1 + tokenBalances[msg.sender])) : (proposals[_proposalId].noVotes == (_v.old_2 + tokenBalances[msg.sender])))) {
                emit __ScribbleUtilsLib__346.AssertionFailed("005116:0068:000 11: ");
                assert(false);
            }
        }
    }

    function _original_SimpleDAO_vote(uint256 _proposalId, bool _support) internal onlyTokenHolder() {
        Proposal storage proposal = proposals[_proposalId];
        require(block.timestamp >= proposal.startTime, "Voting not started");
        require(block.timestamp <= proposal.endTime, "Voting ended");
        require(!proposal.hasVoted[msg.sender], "Already voted");
        proposal.hasVoted[msg.sender] = true;
        if (_support) {
            proposal.yesVotes += tokenBalances[msg.sender];
        } else {
            proposal.noVotes += tokenBalances[msg.sender];
        }
        emit VoteCast(_proposalId, msg.sender, _support);
    }

    function finalize(uint256 _proposalId) external {
        _original_SimpleDAO_finalize(_proposalId);
        unchecked {
            if (!(block.timestamp > proposals[_proposalId].endTime)) {
                emit __ScribbleUtilsLib__346.AssertionFailed("006118:0068:000 12: ");
                assert(false);
            }
            if (!(!proposals[_proposalId].executed)) {
                emit __ScribbleUtilsLib__346.AssertionFailed("006304:0068:000 13: ");
                assert(false);
            }
            if (!(proposals[_proposalId].executed)) {
                emit __ScribbleUtilsLib__346.AssertionFailed("006489:0068:000 14: ");
                assert(false);
            }
        }
    }

    function _original_SimpleDAO_finalize(uint256 _proposalId) internal {
        Proposal storage proposal = proposals[_proposalId];
        require(block.timestamp > proposal.endTime, "Voting still in progress");
        require(!proposal.executed, "Proposal already executed");
        proposal.executed = true;
        bool passed = proposal.yesVotes > proposal.noVotes;
        emit ProposalExecuted(_proposalId, passed);
    }

    function setTokenBalance(address _account, uint256 _amount) external {
        _original_SimpleDAO_setTokenBalance(_account, _amount);
        unchecked {
            if (!(msg.sender == admin)) {
                emit __ScribbleUtilsLib__346.AssertionFailed("007272:0068:000 15: ");
                assert(false);
            }
            if (!(tokenBalances[_account] == _amount)) {
                emit __ScribbleUtilsLib__346.AssertionFailed("007460:0068:000 16: ");
                assert(false);
            }
        }
    }

    function _original_SimpleDAO_setTokenBalance(address _account, uint256 _amount) internal onlyAdmin() {
        tokenBalances[_account] = _amount;
    }

    function getProposal(uint256 _proposalId) external view returns (string memory description, uint256 yesVotes, uint256 noVotes, uint256 startTime, uint256 endTime, bool executed) {
        Proposal storage proposal = proposals[_proposalId];
        return (proposal.description, proposal.yesVotes, proposal.noVotes, proposal.startTime, proposal.endTime, proposal.executed);
    }
}

library __ScribbleUtilsLib__346 {
    event AssertionFailed(string message);

    event AssertionFailedData(int eventId, bytes encodingData);

    function assertionFailed(string memory arg_0) internal {
        emit AssertionFailed(arg_0);
    }

    function assertionFailedData(int arg_0, bytes memory arg_1) internal {
        emit AssertionFailedData(arg_0, arg_1);
    }

    function isInContract() internal returns (bool res) {
        assembly {
            res := sload(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c)
        }
    }

    function setInContract(bool v) internal {
        assembly {
            sstore(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c, v)
        }
    }
}