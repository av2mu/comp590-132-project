/// This file is auto-generated by Scribble and shouldn't be edited directly.
/// Use --disarm prior to make any changes.
/// SPDX-License-Identifier: MIT
pragma solidity ^0.8.29;

/// @title SimpleDAO
///  @notice A simple DAO voting mechanism with token-weighted voting
contract SimpleDAO {
    event ProposalCreated(uint256 indexed proposalId, string description);

    event VoteCast(uint256 indexed proposalId, address indexed voter, bool support);

    event ProposalExecuted(uint256 indexed proposalId, bool passed);

    struct Proposal {
        string description;
        uint256 yesVotes;
        uint256 noVotes;
        uint256 startTime;
        uint256 endTime;
        bool executed;
        mapping(address => bool) hasVoted;
    }

    struct vars1 {
        uint256 old_0;
    }

    struct vars2 {
        uint256 old_1;
        uint256 old_2;
    }

    struct vars4 {
        uint256 old_3;
        uint256 old_4;
    }

    address public admin;
    mapping(uint256 => Proposal) public proposals;
    mapping(address => uint256) public tokenBalances;
    uint256 public proposalCount;
    uint256 public constant QUORUM_THRESHOLD = 30;
    uint256 public totalTokens;

    modifier onlyAdmin() {
        require(msg.sender == admin, "Only admin can call this function");
        _;
    }

    modifier onlyTokenHolder() {
        require(tokenBalances[msg.sender] > 0, "Must be a token holder");
        _;
    }

    /// #if_succeeds {:msg "Admin is set in constructor"} admin == msg.sender;
    constructor() {
        admin = msg.sender;
        unchecked {
            if (!(admin == msg.sender)) {
                emit __ScribbleUtilsLib__391.AssertionFailed("001643:0094:000 0: Admin is set in constructor");
                assert(false);
            }
        }
    }

    function createProposal(string memory _description, uint256 _votingPeriod) external returns (uint256 RET_0) {
        vars1 memory _v;
        unchecked {
            _v.old_0 = proposalCount;
        }
        RET_0 = _original_SimpleDAO_createProposal(_description, _votingPeriod);
        unchecked {
            if (!(msg.sender == admin)) {
                emit __ScribbleUtilsLib__391.AssertionFailed("002167:0098:000 1: Only admin can create proposals");
                assert(false);
            }
            if (!(proposalCount == (_v.old_0 + 1))) {
                emit __ScribbleUtilsLib__391.AssertionFailed("002382:0093:000 2: Proposal ID is incremented");
                assert(false);
            }
            if (!((_votingPeriod > 0) && (_votingPeriod <= 604800))) {
                emit __ScribbleUtilsLib__391.AssertionFailed("002609:0089:000 3: Voting period is valid");
                assert(false);
            }
        }
    }

    function _original_SimpleDAO_createProposal(string memory _description, uint256 _votingPeriod) internal onlyAdmin() returns (uint256) {
        require((_votingPeriod > 0) && (_votingPeriod <= 7 days), "Invalid voting period");
        uint256 proposalId = proposalCount++;
        Proposal storage proposal = proposals[proposalId];
        proposal.description = _description;
        proposal.startTime = block.timestamp;
        proposal.endTime = block.timestamp + _votingPeriod;
        emit ProposalCreated(proposalId, _description);
        return proposalId;
    }

    function vote(uint256 _proposalId, bool _support) virtual external {
        vars2 memory _v;
        unchecked {
            _v.old_1 = proposals[_proposalId].yesVotes;
            _v.old_2 = proposals[_proposalId].noVotes;
        }
        _original_SimpleDAO_vote(_proposalId, _support);
        unchecked {
            if (!(tokenBalances[msg.sender] > 0)) {
                emit __ScribbleUtilsLib__391.AssertionFailed("003724:0094:000 4: Only token holders can vote");
                assert(false);
            }
            if (!(proposals[_proposalId].hasVoted[msg.sender])) {
                emit __ScribbleUtilsLib__391.AssertionFailed("003947:0090:000 5: Single vote per address");
                assert(false);
            }
            if (!(((!_support) || (proposals[_proposalId].yesVotes == (_v.old_1 + tokenBalances[msg.sender]))) && ((!(!_support)) || (proposals[_proposalId].noVotes == (_v.old_2 + tokenBalances[msg.sender]))))) {
                emit __ScribbleUtilsLib__391.AssertionFailed("004313:0089:000 6: Vote weight is correct");
                assert(false);
            }
        }
    }

    function _original_SimpleDAO_vote(uint256 _proposalId, bool _support) internal onlyTokenHolder() {
        Proposal storage proposal = proposals[_proposalId];
        require(block.timestamp >= proposal.startTime, "Voting not started");
        require(block.timestamp <= proposal.endTime, "Voting ended");
        require(!proposal.executed, "Proposal already finalized");
        require(!proposal.hasVoted[msg.sender], "Already voted");
        proposal.hasVoted[msg.sender] = true;
        uint256 voteWeight = tokenBalances[msg.sender];
        if (_support) {
            proposal.yesVotes += voteWeight;
        } else {
            proposal.noVotes += voteWeight;
        }
        emit VoteCast(_proposalId, msg.sender, _support);
    }

    function finalize(uint256 _proposalId) virtual external {
        _original_SimpleDAO_finalize(_proposalId);
        unchecked {
            if (!((proposals[_proposalId].yesVotes + proposals[_proposalId].noVotes) >= ((totalTokens * QUORUM_THRESHOLD) / 100))) {
                emit __ScribbleUtilsLib__391.AssertionFailed("005499:0080:000 7: Quorum is met");
                assert(false);
            }
            if (!(proposals[_proposalId].executed)) {
                emit __ScribbleUtilsLib__391.AssertionFailed("005696:0097:000 8: Proposal is marked as executed");
                assert(false);
            }
        }
    }

    function _original_SimpleDAO_finalize(uint256 _proposalId) internal {
        Proposal storage proposal = proposals[_proposalId];
        require(block.timestamp > proposal.endTime, "Voting still in progress");
        require(!proposal.executed, "Proposal already executed");
        uint256 totalVotes = proposal.yesVotes + proposal.noVotes;
        require(totalVotes >= ((totalTokens * QUORUM_THRESHOLD) / 100), "Quorum not met");
        proposal.executed = true;
        bool passed = proposal.yesVotes > proposal.noVotes;
        emit ProposalExecuted(_proposalId, passed);
    }

    function setTokenBalance(address _account, uint256 _amount) external {
        vars4 memory _v;
        unchecked {
            _v.old_3 = totalTokens;
            _v.old_4 = tokenBalances[_account];
        }
        _original_SimpleDAO_setTokenBalance(_account, _amount);
        unchecked {
            if (!(msg.sender == admin)) {
                emit __ScribbleUtilsLib__391.AssertionFailed("006805:0100:000 9: Only admin can set token balances");
                assert(false);
            }
            if (!(totalTokens == ((_v.old_3 - _v.old_4) + _amount))) {
                emit __ScribbleUtilsLib__391.AssertionFailed("007039:0101:000 10: Total tokens is updated correctly");
                assert(false);
            }
        }
    }

    function _original_SimpleDAO_setTokenBalance(address _account, uint256 _amount) internal onlyAdmin() {
        uint256 oldBalance = tokenBalances[_account];
        tokenBalances[_account] = _amount;
        totalTokens = (totalTokens - oldBalance) + _amount;
    }

    function getProposal(uint256 _proposalId) external view returns (string memory description, uint256 yesVotes, uint256 noVotes, uint256 startTime, uint256 endTime, bool executed) {
        Proposal storage proposal = proposals[_proposalId];
        return (proposal.description, proposal.yesVotes, proposal.noVotes, proposal.startTime, proposal.endTime, proposal.executed);
    }
}

library __ScribbleUtilsLib__391 {
    event AssertionFailed(string message);

    event AssertionFailedData(int eventId, bytes encodingData);

    function assertionFailed(string memory arg_0) internal {
        emit AssertionFailed(arg_0);
    }

    function assertionFailedData(int arg_0, bytes memory arg_1) internal {
        emit AssertionFailedData(arg_0, arg_1);
    }

    function isInContract() internal returns (bool res) {
        assembly {
            res := sload(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c)
        }
    }

    function setInContract(bool v) internal {
        assembly {
            sstore(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c, v)
        }
    }
}