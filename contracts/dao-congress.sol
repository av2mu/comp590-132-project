/// This file is auto-generated by Scribble and shouldn't be edited directly.
/// Use --disarm prior to make any changes.
pragma solidity >=0.4.22<0.6.0;

contract owned {
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    constructor() public {
        owner = msg.sender;
    }

    function transferOwnership(address newOwner) public onlyOwner() {
        owner = newOwner;
    }
}

contract tokenRecipient {
    event receivedEther(address sender, uint amount);

    event receivedTokens(address _from, uint256 _value, address _token, bytes _extraData);

    function receiveApproval(address _from, uint256 _value, address _token, bytes memory _extraData) public {
        Token t = Token(_token);
        require(t.transferFrom(_from, address(this), _value));
        emit receivedTokens(_from, _value, _token, _extraData);
    }

    function () external payable {
        emit receivedEther(msg.sender, msg.value);
    }
}

interface Token {
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
}

contract Congress is owned, tokenRecipient {
    event ProposalAdded(uint proposalID, address recipient, uint amount, string description);

    event Voted(uint proposalID, bool position, address voter, string justification);

    event ProposalTallied(uint proposalID, int result, uint quorum, bool active);

    event MembershipChanged(address member, bool isMember);

    event ChangeOfRules(uint newMinimumQuorum, uint newDebatingPeriodInMinutes, int newMajorityMargin);

    struct Proposal {
        address recipient;
        uint amount;
        string description;
        uint minExecutionDate;
        bool executed;
        bool proposalPassed;
        uint numberOfVotes;
        int currentResult;
        bytes32 proposalHash;
        Vote[] votes;
        mapping(address => bool) voted;
    }

    struct Member {
        address member;
        string name;
        uint memberSince;
    }

    struct Vote {
        bool inSupport;
        address voter;
        string justification;
    }

    struct vars0 {
        uint256 old_0;
    }

    struct vars1 {
        int256 old_1;
        int256 old_2;
    }

    uint public minimumQuorum;
    uint public debatingPeriodInMinutes;
    int public majorityMargin;
    Proposal[] public proposals;
    uint public numProposals;
    mapping(address => uint) public memberId;
    Member[] public members;

    modifier onlyMembers() {
        require(memberId[msg.sender] != 0);
        _;
    }

    /// Constructor
    constructor(uint minimumQuorumForProposals, uint minutesForDebate, int marginOfVotesForMajority) public payable {
        changeVotingRules(minimumQuorumForProposals, minutesForDebate, marginOfVotesForMajority);
        addMember(address(0), "");
        addMember(owner, "founder");
    }

    /// Add member
    function addMember(address targetMember, string memory memberName) public onlyOwner() {
        uint id = memberId[targetMember];
        if (id == 0) {
            memberId[targetMember] = members.length;
            id = members.length++;
        }
        members[id] = Member({member: targetMember, memberSince: now, name: memberName});
        emit MembershipChanged(targetMember, true);
    }

    /// Remove member
    function removeMember(address targetMember) public onlyOwner() {
        require(memberId[targetMember] != 0);
        for (uint i = memberId[targetMember]; i < (members.length - 1); i++) {
            members[i] = members[i + 1];
            memberId[members[i].member] = i;
        }
        memberId[targetMember] = 0;
        delete members[members.length - 1];
        members.length--;
    }

    /// Change voting rules
    function changeVotingRules(uint minimumQuorumForProposals, uint minutesForDebate, int marginOfVotesForMajority) public onlyOwner() {
        minimumQuorum = minimumQuorumForProposals;
        debatingPeriodInMinutes = minutesForDebate;
        majorityMargin = marginOfVotesForMajority;
        emit ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, majorityMargin);
    }

    function newProposal(address beneficiary, uint weiAmount, string memory jobDescription, bytes memory transactionBytecode) public returns (uint proposalID) {
        vars0 memory _v;
        _v.old_0 = numProposals;
        proposalID = _original_Congress_newProposal(beneficiary, weiAmount, jobDescription, transactionBytecode);
        if (!(memberId[msg.sender] != 0)) {
            __ScribbleUtilsLib__733.assertionFailed("004543:0095:000 0: Only members can create proposals");
            assert(false);
        }
        if (!(numProposals == (_v.old_0 + 1))) {
            __ScribbleUtilsLib__733.assertionFailed("004738:0088:000 1: Proposal ID is incremented");
            assert(false);
        }
    }

    function _original_Congress_newProposal(address beneficiary, uint weiAmount, string memory jobDescription, bytes memory transactionBytecode) internal onlyMembers() returns (uint proposalID) {
        proposalID = proposals.length++;
        Proposal storage p = proposals[proposalID];
        p.recipient = beneficiary;
        p.amount = weiAmount;
        p.description = jobDescription;
        p.proposalHash = keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));
        p.minExecutionDate = now + (debatingPeriodInMinutes * 1 minutes);
        p.executed = false;
        p.proposalPassed = false;
        p.numberOfVotes = 0;
        emit ProposalAdded(proposalID, beneficiary, weiAmount, jobDescription);
        numProposals = proposalID + 1;
        return proposalID;
    }

    /// Add proposal in Ether
    /// 
    /// Propose to send `etherAmount` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.
    /// This is a convenience function to use if the amount to be given is in round number of ether units.
    /// 
    /// @param beneficiary who to send the ether to
    /// @param etherAmount amount of ether to send
    /// @param jobDescription Description of job
    /// @param transactionBytecode bytecode of transaction
    function newProposalInEther(address beneficiary, uint etherAmount, string memory jobDescription, bytes memory transactionBytecode) public onlyMembers() returns (uint proposalID) {
        return newProposal(beneficiary, etherAmount * 1 ether, jobDescription, transactionBytecode);
    }

    /// Check if a proposal code matches
    /// 
    /// @param proposalNumber ID number of the proposal to query
    /// @param beneficiary who to send the ether to
    /// @param weiAmount amount of ether to send
    /// @param transactionBytecode bytecode of transaction
    function checkProposalCode(uint proposalNumber, address beneficiary, uint weiAmount, bytes memory transactionBytecode) public view returns (bool codeChecksOut) {
        Proposal storage p = proposals[proposalNumber];
        return p.proposalHash == keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));
    }

    function vote(uint proposalNumber, bool supportsProposal, string memory justificationText) public returns (uint voteID) {
        vars1 memory _v;
        _v.old_1 = proposals[proposalNumber].currentResult;
        _v.old_2 = proposals[proposalNumber].currentResult;
        voteID = _original_Congress_vote(proposalNumber, supportsProposal, justificationText);
        if (!(memberId[msg.sender] != 0)) {
            __ScribbleUtilsLib__733.assertionFailed("007515:0083:000 2: Only members can vote");
            assert(false);
        }
        if (!(proposals[proposalNumber].voted[msg.sender] == true)) {
            __ScribbleUtilsLib__733.assertionFailed("007719:0085:000 3: Single vote per address");
            assert(false);
        }
        if (!(((!supportsProposal) || (proposals[proposalNumber].currentResult == (_v.old_1 + 1))) && ((!(!supportsProposal)) || (proposals[proposalNumber].currentResult == (_v.old_2 - 1))))) {
            __ScribbleUtilsLib__733.assertionFailed("008049:0084:000 4: Vote weight is correct");
            assert(false);
        }
        if (!(now <= proposals[proposalNumber].minExecutionDate)) {
            __ScribbleUtilsLib__733.assertionFailed("008252:0084:000 5: Voting period is valid");
            assert(false);
        }
    }

    function _original_Congress_vote(uint proposalNumber, bool supportsProposal, string memory justificationText) internal onlyMembers() returns (uint voteID) {
        Proposal storage p = proposals[proposalNumber];
        require(!p.voted[msg.sender]);
        p.voted[msg.sender] = true;
        p.numberOfVotes++;
        if (supportsProposal) {
            p.currentResult++;
        } else {
            p.currentResult--;
        }
        emit Voted(proposalNumber, supportsProposal, msg.sender, justificationText);
        return p.numberOfVotes;
    }

    function executeProposal(uint proposalNumber, bytes memory transactionBytecode) public {
        _original_Congress_executeProposal(proposalNumber, transactionBytecode);
        if (!(proposals[proposalNumber].numberOfVotes >= minimumQuorum)) {
            __ScribbleUtilsLib__733.assertionFailed("009207:0092:000 6: Quorum is met before execution");
            assert(false);
        }
        if (!(now > proposals[proposalNumber].minExecutionDate)) {
            __ScribbleUtilsLib__733.assertionFailed("009417:0085:000 7: Voting period has ended");
            assert(false);
        }
        if (!(!proposals[proposalNumber].executed)) {
            __ScribbleUtilsLib__733.assertionFailed("009607:0091:000 8: Proposal not already executed");
            assert(false);
        }
        if (!(proposals[proposalNumber].proposalHash == keccak256(abi.encodePacked(proposals[proposalNumber].recipient, proposals[proposalNumber].amount, transactionBytecode)))) {
            __ScribbleUtilsLib__733.assertionFailed("009929:0083:000 9: Proposal hash matches");
            assert(false);
        }
    }

    function _original_Congress_executeProposal(uint proposalNumber, bytes memory transactionBytecode) internal {
        Proposal storage p = proposals[proposalNumber];
        require((((now > p.minExecutionDate) && (!p.executed)) && (p.proposalHash == keccak256(abi.encodePacked(p.recipient, p.amount, transactionBytecode)))) && (p.numberOfVotes >= minimumQuorum));
        if (p.currentResult > majorityMargin) {
            p.executed = true;
            (bool success, ) = p.recipient.call.value(p.amount)(transactionBytecode);
            require(success);
            p.proposalPassed = true;
        } else {
            p.proposalPassed = false;
        }
        emit ProposalTallied(proposalNumber, p.currentResult, p.numberOfVotes, p.proposalPassed);
    }
}

library __ScribbleUtilsLib__733 {
    event AssertionFailed(string message);

    event AssertionFailedData(int eventId, bytes encodingData);

    function assertionFailed(string memory arg_0) internal {
        emit AssertionFailed(arg_0);
    }

    function assertionFailedData(int arg_0, bytes memory arg_1) internal {
        emit AssertionFailedData(arg_0, arg_1);
    }

    function isInContract() internal returns (bool res) {
        assembly {
            res := sload(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c)
        }
    }

    function setInContract(bool v) internal {
        assembly {
            sstore(0x5f0b92cf9616afdee4f4136f66393f1343b027f01be893fa569eb2e2b667a40c, v)
        }
    }
}